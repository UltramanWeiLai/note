# 函数

## 参数

### 默认参数

```
    // 参数的默认值要放在参数的后面
    const fn = function(x, y = 1) {
        return x + y
    }
    fn(1) // 2
```

### 结合解构

```
    const fn = function({ x, y = 1 }) {
        return x + y
    }
    fn({x: 1, y: 2}) // 3
```

### 属性

### name

```
    function foo() {}
    foo.name // foo

    (new Function).name // anonymous

    foo.bind({}).name // bound foo

    (function(){}).bind({}).name // bound
```

### length

返回没有定义默认值的参数个数

```
    const fn = function({ x, y = 1 }) {
        return x + y
    }
    fn.length // 1
```

## 函数作用域

```
    {
        const x = 10
        const fn = function(x, y = x) {
            return x + y
        }
        fn(2) // 4
    }

    {
        // 执行 y = x 的时候 x 没有定义所向上级作用域查找
        // 执行 const x 的时候，其实当前作用域是没有 x 这个变量的所以可以执行的
        // 关于 变量无法重复定义和无法提前使用 这个其实仔细想一下就能明白
        const x = 10
        const fn = function(y = x) {
            const x = 1
            return y
        }
        fn(2) // 10
    }

    // -------------------

    {
        // 函数还有个一个特性，对于作用域提升
        // 函数作用域内找不到一个 变量 或者 常量 的时候，向上级作用域进行查找
        // 查找的上级作用域是函数定义时候位置的，而不是执行时候位置的

        const a = 10
        const fn = function(x, y) {
            return x + y + a
        }

        const fn2 = function(x, y) {
            const a = 100
            return fn(x, y)
        }

        fn2(1, 2) // 13
    }
```
